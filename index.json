{
  "api/Platform.Data.ConsoleTerminal.html": {
    "href": "api/Platform.Data.ConsoleTerminal.html",
    "title": "Namespace Platform.Data.ConsoleTerminal | LinksPlatform",
    "keywords": "Namespace Platform.Data.ConsoleTerminal Classes Program"
  },
  "api/Platform.Data.ConsoleTerminal.Program.html": {
    "href": "api/Platform.Data.ConsoleTerminal.Program.html",
    "title": "Class Program | LinksPlatform",
    "keywords": "Class Program Inheritance System.Object Program Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.ConsoleTerminal Assembly : cs.temp.dll.dll Syntax public class Program Methods Main(String[]) Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  },
  "api/Platform.Data.MasterServer.html": {
    "href": "api/Platform.Data.MasterServer.html",
    "title": "Namespace Platform.Data.MasterServer | LinksPlatform",
    "keywords": "Namespace Platform.Data.MasterServer Classes Program"
  },
  "api/Platform.Data.MasterServer.Program.html": {
    "href": "api/Platform.Data.MasterServer.Program.html",
    "title": "Class Program | LinksPlatform",
    "keywords": "Class Program Inheritance System.Object Program Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.MasterServer Assembly : cs.temp.dll.dll Syntax public class Program Methods Main(String[]) Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  },
  "api/Platform.Data.SlaveServer.html": {
    "href": "api/Platform.Data.SlaveServer.html",
    "title": "Namespace Platform.Data.SlaveServer | LinksPlatform",
    "keywords": "Namespace Platform.Data.SlaveServer Classes Program"
  },
  "api/Platform.Data.SlaveServer.Program.html": {
    "href": "api/Platform.Data.SlaveServer.Program.html",
    "title": "Class Program | LinksPlatform",
    "keywords": "Class Program Inheritance System.Object Program Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.SlaveServer Assembly : cs.temp.dll.dll Syntax public class Program Methods Main(String[]) Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  },
  "api/Platform.Data.WebTerminal.Controllers.HomeController.html": {
    "href": "api/Platform.Data.WebTerminal.Controllers.HomeController.html",
    "title": "Class HomeController | LinksPlatform",
    "keywords": "Class HomeController Inheritance System.Object HomeController Namespace : Platform.Data.WebTerminal.Controllers Assembly : cs.temp.dll.dll Syntax public class HomeController : Controller Methods Error() Declaration public IActionResult Error() Returns Type Description IActionResult Index() Declaration public IActionResult Index() Returns Type Description IActionResult Privacy() Declaration public IActionResult Privacy() Returns Type Description IActionResult"
  },
  "api/Platform.Data.WebTerminal.Controllers.html": {
    "href": "api/Platform.Data.WebTerminal.Controllers.html",
    "title": "Namespace Platform.Data.WebTerminal.Controllers | LinksPlatform",
    "keywords": "Namespace Platform.Data.WebTerminal.Controllers Classes HomeController LinksController"
  },
  "api/Platform.Data.WebTerminal.Controllers.LinksController.html": {
    "href": "api/Platform.Data.WebTerminal.Controllers.LinksController.html",
    "title": "Class LinksController | LinksPlatform",
    "keywords": "Class LinksController Inheritance System.Object LinksController Namespace : Platform.Data.WebTerminal.Controllers Assembly : cs.temp.dll.dll Syntax public class LinksController : Controller Methods Index(Int64) Declaration public IActionResult Index(long id = 0L) Parameters Type Name Description System.Int64 id Returns Type Description IActionResult Infinite(Int64) Declaration public IActionResult Infinite(long id = 0L) Parameters Type Name Description System.Int64 id Returns Type Description IActionResult"
  },
  "api/Platform.Data.WebTerminal.html": {
    "href": "api/Platform.Data.WebTerminal.html",
    "title": "Namespace Platform.Data.WebTerminal | LinksPlatform",
    "keywords": "Namespace Platform.Data.WebTerminal Classes Program Startup"
  },
  "api/Platform.Data.WebTerminal.Models.ErrorViewModel.html": {
    "href": "api/Platform.Data.WebTerminal.Models.ErrorViewModel.html",
    "title": "Class ErrorViewModel | LinksPlatform",
    "keywords": "Class ErrorViewModel Inheritance System.Object ErrorViewModel Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.WebTerminal.Models Assembly : cs.temp.dll.dll Syntax public class ErrorViewModel Properties RequestId Declaration public string RequestId { get; set; } Property Value Type Description System.String ShowRequestId Declaration public bool ShowRequestId { get; } Property Value Type Description System.Boolean"
  },
  "api/Platform.Data.WebTerminal.Models.html": {
    "href": "api/Platform.Data.WebTerminal.Models.html",
    "title": "Namespace Platform.Data.WebTerminal.Models | LinksPlatform",
    "keywords": "Namespace Platform.Data.WebTerminal.Models Classes ErrorViewModel LinkModel"
  },
  "api/Platform.Data.WebTerminal.Models.LinkModel.html": {
    "href": "api/Platform.Data.WebTerminal.Models.LinkModel.html",
    "title": "Class LinkModel | LinksPlatform",
    "keywords": "Class LinkModel Inheritance System.Object LinkModel Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.WebTerminal.Models Assembly : cs.temp.dll.dll Syntax public class LinkModel Constructors LinkModel(Link) Declaration public LinkModel(Link link) Parameters Type Name Description Link link LinkModel(Link, List<LinkModel>) Declaration public LinkModel(Link link, List<LinkModel> referersModels) Parameters Type Name Description Link link System.Collections.Generic.List < LinkModel > referersModels Properties Link Declaration public Link Link { get; set; } Property Value Type Description Link ReferersModels Declaration public List<LinkModel> ReferersModels { get; set; } Property Value Type Description System.Collections.Generic.List < LinkModel > Methods CreateLinkModel(Link, Int32) Declaration public static LinkModel CreateLinkModel(Link link, int nestingLevel = 5) Parameters Type Name Description Link link System.Int32 nestingLevel Returns Type Description LinkModel"
  },
  "api/Platform.Data.WebTerminal.Program.html": {
    "href": "api/Platform.Data.WebTerminal.Program.html",
    "title": "Class Program | LinksPlatform",
    "keywords": "Class Program Inheritance System.Object Program Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.WebTerminal Assembly : cs.temp.dll.dll Syntax public class Program Methods CreateWebHostBuilder(String[]) Declaration public static IWebHostBuilder CreateWebHostBuilder(string[] args) Parameters Type Name Description System.String [] args Returns Type Description IWebHostBuilder Main(String[]) Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  },
  "api/Platform.Data.WebTerminal.Startup.html": {
    "href": "api/Platform.Data.WebTerminal.Startup.html",
    "title": "Class Startup | LinksPlatform",
    "keywords": "Class Startup Inheritance System.Object Startup Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Data.WebTerminal Assembly : cs.temp.dll.dll Syntax public class Startup Constructors Startup(IConfiguration) Declaration public Startup(IConfiguration configuration) Parameters Type Name Description IConfiguration configuration Properties Configuration Declaration public IConfiguration Configuration { get; } Property Value Type Description IConfiguration Methods Configure(IApplicationBuilder, IHostingEnvironment) Declaration public void Configure(IApplicationBuilder app, IHostingEnvironment env) Parameters Type Name Description IApplicationBuilder app IHostingEnvironment env ConfigureServices(IServiceCollection) Declaration public void ConfigureServices(IServiceCollection services) Parameters Type Name Description IServiceCollection services"
  },
  "api/Platform.Examples.CSVExporter.html": {
    "href": "api/Platform.Examples.CSVExporter.html",
    "title": "Class CSVExporter | LinksPlatform",
    "keywords": "Class CSVExporter Inheritance System.Object CSVExporter CSVSequencesExporter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class CSVExporter Remarks https://tools.ietf.org/html/rfc4180 Fields _addressToLineNumber Declaration protected Dictionary<ulong, ulong> _addressToLineNumber Field Value Type Description System.Collections.Generic.Dictionary < System.UInt64 , System.UInt64 > _convertUnicodeLinksToCharacters Declaration protected bool _convertUnicodeLinksToCharacters Field Value Type Description System.Boolean _linesCounter Declaration protected ulong _linesCounter Field Value Type Description System.UInt64 _links Declaration protected SynchronizedLinks<ulong> _links Field Value Type Description SynchronizedLinks < System.UInt64 > _linksCounter Declaration protected ulong _linksCounter Field Value Type Description System.UInt64 _referenceByLines Declaration protected bool _referenceByLines Field Value Type Description System.Boolean _unicodeMapped Declaration protected bool _unicodeMapped Field Value Type Description System.Boolean _visited Declaration protected HashSet<ulong> _visited Field Value Type Description HashSet < System.UInt64 > Methods Export(SynchronizedLinks<UInt64>, String, Boolean, Boolean, Boolean, CancellationToken) Declaration public void Export(SynchronizedLinks<ulong> links, string path, bool unicodeMapped, bool convertUnicodeLinksToCharacters, bool referenceByLines, CancellationToken cancellationToken) Parameters Type Name Description SynchronizedLinks < System.UInt64 > links System.String path System.Boolean unicodeMapped System.Boolean convertUnicodeLinksToCharacters System.Boolean referenceByLines CancellationToken cancellationToken FormatLink(UInt64) Declaration protected string FormatLink(ulong link) Parameters Type Name Description System.UInt64 link Returns Type Description System.String Visit(UInt64) Declaration protected bool Visit(ulong linkIndex) Parameters Type Name Description System.UInt64 linkIndex Returns Type Description System.Boolean WriteLink(StreamWriter, IList<UInt64>) Declaration protected virtual void WriteLink(StreamWriter writer, IList<ulong> link) Parameters Type Name Description StreamWriter writer System.Collections.Generic.IList < System.UInt64 > link"
  },
  "api/Platform.Examples.CSVExporterCLI-1.html": {
    "href": "api/Platform.Examples.CSVExporterCLI-1.html",
    "title": "Class CSVExporterCLI<TExporter> | LinksPlatform",
    "keywords": "Class CSVExporterCLI<TExporter> Inheritance System.Object CSVExporterCLI<TExporter> Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class CSVExporterCLI<TExporter> : ICommandLineInterface where TExporter : CSVExporter, new() Type Parameters Name Description TExporter Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.CSVSequencesExporter.html": {
    "href": "api/Platform.Examples.CSVSequencesExporter.html",
    "title": "Class CSVSequencesExporter | LinksPlatform",
    "keywords": "Class CSVSequencesExporter Inheritance System.Object CSVExporter CSVSequencesExporter Inherited Members CSVExporter._links CSVExporter._unicodeMapped CSVExporter._convertUnicodeLinksToCharacters CSVExporter._referenceByLines CSVExporter._visited CSVExporter._addressToLineNumber CSVExporter._linksCounter CSVExporter._linesCounter CSVExporter.Export(SynchronizedLinks<UInt64>, String, Boolean, Boolean, Boolean, CancellationToken) CSVExporter.Visit(UInt64) CSVExporter.FormatLink(UInt64) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class CSVSequencesExporter : CSVExporter Methods WriteLink(StreamWriter, IList<UInt64>) Declaration protected override void WriteLink(StreamWriter writer, IList<ulong> link) Parameters Type Name Description StreamWriter writer System.Collections.Generic.IList < System.UInt64 > link Overrides CSVExporter.WriteLink(StreamWriter, IList<UInt64>)"
  },
  "api/Platform.Examples.FileIndexer.html": {
    "href": "api/Platform.Examples.FileIndexer.html",
    "title": "Class FileIndexer | LinksPlatform",
    "keywords": "Class FileIndexer Inheritance System.Object FileIndexer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class FileIndexer Constructors FileIndexer(SynchronizedLinks<UInt64>, SequenceIndex<UInt64>) Declaration public FileIndexer(SynchronizedLinks<ulong> links, SequenceIndex<ulong> indexer) Parameters Type Name Description SynchronizedLinks < System.UInt64 > links SequenceIndex < System.UInt64 > indexer Methods IndexAsync(String, CancellationToken) Declaration public async Task IndexAsync(string path, CancellationToken cancellationToken) Parameters Type Name Description System.String path CancellationToken cancellationToken Returns Type Description System.Threading.Tasks.Task IndexParallel(String, CancellationToken) Declaration public void IndexParallel(string path, CancellationToken cancellationToken) Parameters Type Name Description System.String path CancellationToken cancellationToken IndexSync(String, CancellationToken) Declaration public void IndexSync(string path, CancellationToken cancellationToken) Parameters Type Name Description System.String path CancellationToken cancellationToken"
  },
  "api/Platform.Examples.FileIndexerCLI.html": {
    "href": "api/Platform.Examples.FileIndexerCLI.html",
    "title": "Class FileIndexerCLI | LinksPlatform",
    "keywords": "Class FileIndexerCLI Inheritance System.Object FileIndexerCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class FileIndexerCLI : ICommandLineInterface Methods Run(String[]) Declaration public void Run(string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.GEXFCSVExporterCLI.html": {
    "href": "api/Platform.Examples.GEXFCSVExporterCLI.html",
    "title": "Class GEXFCSVExporterCLI | LinksPlatform",
    "keywords": "Class GEXFCSVExporterCLI Inheritance System.Object GEXFCSVExporterCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class GEXFCSVExporterCLI : ICommandLineInterface Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.GEXFExporter-1.html": {
    "href": "api/Platform.Examples.GEXFExporter-1.html",
    "title": "Class GEXFExporter<TLink> | LinksPlatform",
    "keywords": "Class GEXFExporter<TLink> Inheritance System.Object GEXFExporter<TLink> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class GEXFExporter<TLink> Type Parameters Name Description TLink Constructors GEXFExporter(ILinks<TLink>) Declaration public GEXFExporter(ILinks<TLink> links) Parameters Type Name Description ILinks <TLink> links Methods Export(String) Declaration public void Export(string outputFilename) Parameters Type Name Description System.String outputFilename"
  },
  "api/Platform.Examples.html": {
    "href": "api/Platform.Examples.html",
    "title": "Namespace Platform.Examples | LinksPlatform",
    "keywords": "Namespace Platform.Examples Classes CSVExporter CSVExporterCLI<TExporter> CSVSequencesExporter FileIndexer FileIndexerCLI GEXFCSVExporterCLI GEXFExporter<TLink> LinksXmlStorage<TLink> MasterServer MasterServerCLI TerminalCLI XmlElementCounter XmlElementCounterCLI XmlImporter<TLink> XmlImporterCLI XmlIndexer<TLink> XUnitTestsRunnerCLI Interfaces ICommandLineInterface IXmlStorage<TLink>"
  },
  "api/Platform.Examples.ICommandLineInterface.html": {
    "href": "api/Platform.Examples.ICommandLineInterface.html",
    "title": "Interface ICommandLineInterface | LinksPlatform",
    "keywords": "Interface ICommandLineInterface Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public interface ICommandLineInterface Methods Run(String[]) Declaration void Run(params string[] args) Parameters Type Name Description System.String [] args"
  },
  "api/Platform.Examples.IXmlStorage-1.html": {
    "href": "api/Platform.Examples.IXmlStorage-1.html",
    "title": "Interface IXmlStorage<TLink> | LinksPlatform",
    "keywords": "Interface IXmlStorage<TLink> Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public interface IXmlStorage<TLink> Type Parameters Name Description TLink Methods AttachElementToParent(TLink, TLink) Declaration void AttachElementToParent(TLink elementToAttach, TLink parent) Parameters Type Name Description TLink elementToAttach TLink parent CreateDocument(String) Declaration TLink CreateDocument(string name) Parameters Type Name Description System.String name Returns Type Description TLink CreateElement(String) Declaration TLink CreateElement(string name) Parameters Type Name Description System.String name Returns Type Description TLink CreateTextElement(String) Declaration TLink CreateTextElement(string content) Parameters Type Name Description System.String content Returns Type Description TLink"
  },
  "api/Platform.Examples.LinksXmlStorage-1.html": {
    "href": "api/Platform.Examples.LinksXmlStorage-1.html",
    "title": "Class LinksXmlStorage<TLink> | LinksPlatform",
    "keywords": "Class LinksXmlStorage<TLink> Inheritance System.Object LinksXmlStorage<TLink> Implements IXmlStorage <TLink> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class LinksXmlStorage<TLink> : IXmlStorage<TLink> Type Parameters Name Description TLink Constructors LinksXmlStorage(ILinks<TLink>, Boolean, LinkFrequenciesCache<TLink>) Declaration public LinksXmlStorage(ILinks<TLink> links, bool indexSequenceBeforeCreation, LinkFrequenciesCache<TLink> frequenciesCache) Parameters Type Name Description ILinks <TLink> links System.Boolean indexSequenceBeforeCreation LinkFrequenciesCache <TLink> frequenciesCache Methods AttachElementToParent(TLink, TLink) Declaration public void AttachElementToParent(TLink elementToAttach, TLink parent) Parameters Type Name Description TLink elementToAttach TLink parent CreateDocument(String) Declaration public TLink CreateDocument(string name) Parameters Type Name Description System.String name Returns Type Description TLink CreateElement(String) Declaration public TLink CreateElement(string name) Parameters Type Name Description System.String name Returns Type Description TLink CreateTextElement(String) Declaration public TLink CreateTextElement(string content) Parameters Type Name Description System.String content Returns Type Description TLink Implements IXmlStorage<TLink>"
  },
  "api/Platform.Examples.MasterServer.html": {
    "href": "api/Platform.Examples.MasterServer.html",
    "title": "Class MasterServer | LinksPlatform",
    "keywords": "Class MasterServer Inheritance System.Object MasterServer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class MasterServer Constructors MasterServer(ILinks<UInt64>, Sequences, UdpSender) Declaration public MasterServer(ILinks<ulong> links, Sequences sequences, UdpSender sender) Parameters Type Name Description ILinks < System.UInt64 > links Sequences sequences UdpSender sender Methods Create(String) Declaration public void Create(string message) Parameters Type Name Description System.String message IsSearch(String) Declaration public bool IsSearch(string message) Parameters Type Name Description System.String message Returns Type Description System.Boolean PrintContents(Action<String>) Declaration public void PrintContents(Action<string> messageHandler) Parameters Type Name Description System.Action < System.String > messageHandler Search(String) Declaration public void Search(string message) Parameters Type Name Description System.String message"
  },
  "api/Platform.Examples.MasterServerCLI.html": {
    "href": "api/Platform.Examples.MasterServerCLI.html",
    "title": "Class MasterServerCLI | LinksPlatform",
    "keywords": "Class MasterServerCLI Inheritance System.Object MasterServerCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class MasterServerCLI : ICommandLineInterface Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.TerminalCLI.html": {
    "href": "api/Platform.Examples.TerminalCLI.html",
    "title": "Class TerminalCLI | LinksPlatform",
    "keywords": "Class TerminalCLI Inheritance System.Object TerminalCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class TerminalCLI : ICommandLineInterface Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.XmlElementCounter.html": {
    "href": "api/Platform.Examples.XmlElementCounter.html",
    "title": "Class XmlElementCounter | LinksPlatform",
    "keywords": "Class XmlElementCounter Inheritance System.Object XmlElementCounter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class XmlElementCounter Constructors XmlElementCounter() Declaration public XmlElementCounter() Methods Count(String, String, CancellationToken) Declaration public Task Count(string file, string elementName, CancellationToken token) Parameters Type Name Description System.String file System.String elementName CancellationToken token Returns Type Description System.Threading.Tasks.Task"
  },
  "api/Platform.Examples.XmlElementCounterCLI.html": {
    "href": "api/Platform.Examples.XmlElementCounterCLI.html",
    "title": "Class XmlElementCounterCLI | LinksPlatform",
    "keywords": "Class XmlElementCounterCLI Inheritance System.Object XmlElementCounterCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class XmlElementCounterCLI : ICommandLineInterface Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.XmlImporter-1.html": {
    "href": "api/Platform.Examples.XmlImporter-1.html",
    "title": "Class XmlImporter<TLink> | LinksPlatform",
    "keywords": "Class XmlImporter<TLink> Inheritance System.Object XmlImporter<TLink> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class XmlImporter<TLink> Type Parameters Name Description TLink Constructors XmlImporter(IXmlStorage<TLink>) Declaration public XmlImporter(IXmlStorage<TLink> storage) Parameters Type Name Description IXmlStorage <TLink> storage Methods Import(String, CancellationToken) Declaration public Task Import(string file, CancellationToken token) Parameters Type Name Description System.String file CancellationToken token Returns Type Description System.Threading.Tasks.Task"
  },
  "api/Platform.Examples.XmlImporterCLI.html": {
    "href": "api/Platform.Examples.XmlImporterCLI.html",
    "title": "Class XmlImporterCLI | LinksPlatform",
    "keywords": "Class XmlImporterCLI Inheritance System.Object XmlImporterCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class XmlImporterCLI : ICommandLineInterface Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Examples.XmlIndexer-1.html": {
    "href": "api/Platform.Examples.XmlIndexer-1.html",
    "title": "Class XmlIndexer<TLink> | LinksPlatform",
    "keywords": "Class XmlIndexer<TLink> Inheritance System.Object XmlIndexer<TLink> Implements IXmlStorage <TLink> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class XmlIndexer<TLink> : IXmlStorage<TLink> Type Parameters Name Description TLink Constructors XmlIndexer(ILinks<TLink>) Declaration public XmlIndexer(ILinks<TLink> links) Parameters Type Name Description ILinks <TLink> links Properties Cache Declaration public LinkFrequenciesCache<TLink> Cache { get; } Property Value Type Description LinkFrequenciesCache <TLink> Methods AttachElementToParent(TLink, TLink) Declaration public void AttachElementToParent(TLink elementToAttach, TLink parent) Parameters Type Name Description TLink elementToAttach TLink parent CreateDocument(String) Declaration public TLink CreateDocument(string name) Parameters Type Name Description System.String name Returns Type Description TLink CreateElement(String) Declaration public TLink CreateElement(string name) Parameters Type Name Description System.String name Returns Type Description TLink CreateTextElement(String) Declaration public TLink CreateTextElement(string content) Parameters Type Name Description System.String content Returns Type Description TLink ToElements(String) Declaration public IList<TLink> ToElements(string string) Parameters Type Name Description System.String string Returns Type Description System.Collections.Generic.IList <TLink> Implements IXmlStorage<TLink>"
  },
  "api/Platform.Examples.XUnitTestsRunnerCLI.html": {
    "href": "api/Platform.Examples.XUnitTestsRunnerCLI.html",
    "title": "Class XUnitTestsRunnerCLI | LinksPlatform",
    "keywords": "Class XUnitTestsRunnerCLI Inheritance System.Object XUnitTestsRunnerCLI Implements ICommandLineInterface Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Examples Assembly : cs.temp.dll.dll Syntax public class XUnitTestsRunnerCLI : ICommandLineInterface Remarks Based on https://github.com/xunit/samples.xunit/blob/master/TestRunner/Program.cs Constructors XUnitTestsRunnerCLI() Declaration public XUnitTestsRunnerCLI() Properties Succeed Declaration public bool Succeed { get; } Property Value Type Description System.Boolean Methods Run(String[]) Declaration public void Run(params string[] args) Parameters Type Name Description System.String [] args Implements ICommandLineInterface"
  },
  "api/Platform.Sandbox.A.html": {
    "href": "api/Platform.Sandbox.A.html",
    "title": "Class A | LinksPlatform",
    "keywords": "Class A Inheritance System.Object A Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class A Methods Method1() Declaration public static void Method1() Method2() Declaration public static void Method2()"
  },
  "api/Platform.Sandbox.Base.html": {
    "href": "api/Platform.Sandbox.Base.html",
    "title": "Class Base | LinksPlatform",
    "keywords": "Class Base Inheritance System.Object StaticBase < Base > Base Inherited Inherited Members StaticBase<Base>.Instance System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Base : StaticBase<Base> Constructors Base() Declaration public Base() Methods MethodA() Declaration public void MethodA()"
  },
  "api/Platform.Sandbox.CompressionExperiments.Compressor.html": {
    "href": "api/Platform.Sandbox.CompressionExperiments.Compressor.html",
    "title": "Struct CompressionExperiments.Compressor | LinksPlatform",
    "keywords": "Struct CompressionExperiments.Compressor Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public struct Compressor Constructors Compressor(SynchronizedLinks<UInt64>) Declaration public Compressor(SynchronizedLinks<ulong> links) Parameters Type Name Description SynchronizedLinks < System.UInt64 > links Methods Compress(UInt64[]) Declaration public ulong Compress(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 Precompress0(UInt64[]) Declaration public ulong[] Precompress0(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . Faster version (doublets' frequencies dictionary is not recreated). Precompress1(UInt64[]) Declaration public ulong[] Precompress1(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . Faster version (doublets' frequencies dictionary is not recreated). Precompress2(UInt64[]) Declaration public ulong[] Precompress2(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . Faster version (doublets' frequencies dictionary is not recreated). Precompress3(UInt64[]) Declaration public ulong[] Precompress3(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . If doublet repeats twice it is maximum doublet. Precompress4(UInt64[]) Declaration public ulong[] Precompress4(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . If doublet repeats twice it is maximum doublet. Precompress5(UInt64[]) Declaration public ulong[] Precompress5(ulong[] sequence) Parameters Type Name Description System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . Global dictionary"
  },
  "api/Platform.Sandbox.CompressionExperiments.html": {
    "href": "api/Platform.Sandbox.CompressionExperiments.html",
    "title": "Class CompressionExperiments | LinksPlatform",
    "keywords": "Class CompressionExperiments Inheritance System.Object CompressionExperiments Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class CompressionExperiments Methods PrecompressSequence1(SynchronizedLinks<UInt64>, UInt64[]) Declaration public static ulong[] PrecompressSequence1(this SynchronizedLinks<ulong> links, ulong[] sequence) Parameters Type Name Description SynchronizedLinks < System.UInt64 > links System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . Slow version (doublets' frequencies dictionary is recreated). PrecompressSequence2(SynchronizedLinks<UInt64>, UInt64[]) Declaration public static ulong[] PrecompressSequence2(this SynchronizedLinks<ulong> links, ulong[] sequence) Parameters Type Name Description SynchronizedLinks < System.UInt64 > links System.UInt64 [] sequence Returns Type Description System.UInt64 [] Remarks Original algorithm idea: https://en.wikipedia.org/wiki/Byte_pair_encoding . Faster version (doublets' frequencies dictionary is not recreated). Stats() Declaration public static void Stats() Test() Declaration public static void Test()"
  },
  "api/Platform.Sandbox.ConceptTest.html": {
    "href": "api/Platform.Sandbox.ConceptTest.html",
    "title": "Class ConceptTest | LinksPlatform",
    "keywords": "Class ConceptTest Inheritance System.Object ConceptTest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class ConceptTest Methods Test(String) Declaration public static void Test(string filename) Parameters Type Name Description System.String filename TestGexf(String) Declaration public static void TestGexf(string filename) Parameters Type Name Description System.String filename"
  },
  "api/Platform.Sandbox.ConsolePrintedDublicateWalkerBase.html": {
    "href": "api/Platform.Sandbox.ConsolePrintedDublicateWalkerBase.html",
    "title": "Class ConsolePrintedDublicateWalkerBase | LinksPlatform",
    "keywords": "Class ConsolePrintedDublicateWalkerBase Inheritance System.Object ConsolePrintedDublicateWalkerBase Walker1 Walker2 Walker3 Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public abstract class ConsolePrintedDublicateWalkerBase : DuplicateSegmentsWalkerBase<char, CharSegment> Methods CreateSegment(IList<Char>, Int32, Int32) Declaration protected override CharSegment CreateSegment(IList<char> elements, int offset, int length) Parameters Type Name Description System.Collections.Generic.IList < System.Char > elements System.Int32 offset System.Int32 length Returns Type Description CharSegment OnDublicateFound(CharSegment) Declaration protected override void OnDublicateFound(CharSegment segment) Parameters Type Name Description CharSegment segment"
  },
  "api/Platform.Sandbox.DllImportTest.html": {
    "href": "api/Platform.Sandbox.DllImportTest.html",
    "title": "Class DllImportTest | LinksPlatform",
    "keywords": "Class DllImportTest Представляет тест, который позволит определить необходимо ли указывать расширение файла при подключении библиотеки. TODO: Проверить на пользовательских DLL TODO: Далее протестировать на CoreCLR, Mono Inheritance System.Object DllImportTest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class DllImportTest Methods MessageBox(IntPtr, String, String, UInt32) Declaration public static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type) Parameters Type Name Description System.IntPtr hWnd System.String text System.String caption System.UInt32 type Returns Type Description System.Int32 Test() Declaration public static void Test()"
  },
  "api/Platform.Sandbox.FileReadWriteTest.html": {
    "href": "api/Platform.Sandbox.FileReadWriteTest.html",
    "title": "Class FileReadWriteTest | LinksPlatform",
    "keywords": "Class FileReadWriteTest Inheritance System.Object FileReadWriteTest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class FileReadWriteTest Methods MappedFilesTest() Declaration public static void MappedFilesTest() Run(String[]) Declaration public static void Run(string[] args) Parameters Type Name Description System.String [] args SmartTextParsing(Char[], Int32, Int32) Declaration public static Link SmartTextParsing(char[] text, int takeFrom, int takeUntil) Parameters Type Name Description System.Char [] text System.Int32 takeFrom System.Int32 takeUntil Returns Type Description Link"
  },
  "api/Platform.Sandbox.html": {
    "href": "api/Platform.Sandbox.html",
    "title": "Namespace Platform.Sandbox | LinksPlatform",
    "keywords": "Namespace Platform.Sandbox Classes A Base CompressionExperiments ConceptTest ConsolePrintedDublicateWalkerBase DllImportTest Представляет тест, который позволит определить необходимо ли указывать расширение файла при подключении библиотеки. TODO: Проверить на пользовательских DLL TODO: Далее протестировать на CoreCLR, Mono FileReadWriteTest Inherited IterationsCounter NetParser NetParserTest OperationsExperiments Program QueryExecutorExtensions Представляет класс-контейнер расширений для выполнения произвольных запросов над Links StaticBase<TSuccessor> TerminalExperiment TextParser TextParser.State Transactions TreeStructureExperiments Walker1 Walker2 Walker3 Walker4 Zadacha Structs CompressionExperiments.Compressor Enums OperationsExperiments.Mapping"
  },
  "api/Platform.Sandbox.Inherited.html": {
    "href": "api/Platform.Sandbox.Inherited.html",
    "title": "Class Inherited | LinksPlatform",
    "keywords": "Class Inherited Inheritance System.Object StaticBase < Base > Base Inherited Inherited Members StaticBase<Base>.Instance System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Inherited : Base Methods MethodA() Declaration public static void MethodA()"
  },
  "api/Platform.Sandbox.IterationsCounter.html": {
    "href": "api/Platform.Sandbox.IterationsCounter.html",
    "title": "Class IterationsCounter | LinksPlatform",
    "keywords": "Class IterationsCounter Inheritance System.Object IterationsCounter Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class IterationsCounter : AllSegmentsWalkerBase<char> Fields IterationsCount Declaration public long IterationsCount Field Value Type Description System.Int64 Methods Iteration(Segment<Char>) Declaration protected override void Iteration(Segment<char> segment) Parameters Type Name Description Segment < System.Char > segment"
  },
  "api/Platform.Sandbox.NetParser.html": {
    "href": "api/Platform.Sandbox.NetParser.html",
    "title": "Class NetParser | LinksPlatform",
    "keywords": "Class NetParser Inheritance System.Object NetParser Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class NetParser Remarks TODO: Use PEG instead. Methods ParseStatement(String) Declaration public static void ParseStatement(string statement) Parameters Type Name Description System.String statement"
  },
  "api/Platform.Sandbox.NetParserTest.html": {
    "href": "api/Platform.Sandbox.NetParserTest.html",
    "title": "Class NetParserTest | LinksPlatform",
    "keywords": "Class NetParserTest Inheritance System.Object NetParserTest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class NetParserTest Methods Run() Declaration public static void Run()"
  },
  "api/Platform.Sandbox.OperationsExperiments.html": {
    "href": "api/Platform.Sandbox.OperationsExperiments.html",
    "title": "Class OperationsExperiments | LinksPlatform",
    "keywords": "Class OperationsExperiments Inheritance System.Object OperationsExperiments Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class OperationsExperiments Methods RunExperiment() Declaration public static void RunExperiment()"
  },
  "api/Platform.Sandbox.OperationsExperiments.Mapping.html": {
    "href": "api/Platform.Sandbox.OperationsExperiments.Mapping.html",
    "title": "Enum OperationsExperiments.Mapping | LinksPlatform",
    "keywords": "Enum OperationsExperiments.Mapping Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public enum Mapping Fields Name Description Absence Argument As Creation Deletion Execution For From InCaseMatchingValueIs Itself Linker Links OfMatchingOperationFrom Reference Representation Result Selection Source Target ThatExactlyIs To Update With"
  },
  "api/Platform.Sandbox.Program.html": {
    "href": "api/Platform.Sandbox.Program.html",
    "title": "Class Program | LinksPlatform",
    "keywords": "Class Program Inheritance System.Object Program Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Program Methods Main(String[]) Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  },
  "api/Platform.Sandbox.QueryExecutorExtensions.html": {
    "href": "api/Platform.Sandbox.QueryExecutorExtensions.html",
    "title": "Class QueryExecutorExtensions | LinksPlatform",
    "keywords": "Class QueryExecutorExtensions Представляет класс-контейнер расширений для выполнения произвольных запросов над Links Inheritance System.Object QueryExecutorExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class QueryExecutorExtensions Methods Execute<T>(SynchronizedLinks<UInt64>, Expression<Func<SynchronizedLinks<UInt64>, IEnumerable<T>>>) Выполняет запрос query над links и возвращает результат запроса в виде перечисляемого объекта с элементами типа T. Declaration public static IEnumerable<T> Execute<T>(this SynchronizedLinks<ulong> links, Expression<Func<SynchronizedLinks<ulong>, IEnumerable<T>>> query) Parameters Type Name Description SynchronizedLinks < System.UInt64 > links База данных связей, над которой будет выполняться запрос. Expression < System.Func < SynchronizedLinks < System.UInt64 >, System.Collections.Generic.IEnumerable <T>>> query Запрос в виде Linq-выражения. Returns Type Description System.Collections.Generic.IEnumerable <T> Результат запроса в виде перечисляемого объекта с элементами типа T. Type Parameters Name Description T Тип элемента запроса."
  },
  "api/Platform.Sandbox.StaticBase-1.html": {
    "href": "api/Platform.Sandbox.StaticBase-1.html",
    "title": "Class StaticBase<TSuccessor> | LinksPlatform",
    "keywords": "Class StaticBase<TSuccessor> Inheritance System.Object StaticBase<TSuccessor> Base Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public abstract class StaticBase<TSuccessor> where TSuccessor : StaticBase<TSuccessor>, new() Type Parameters Name Description TSuccessor Fields Instance Declaration protected static readonly TSuccessor Instance Field Value Type Description TSuccessor"
  },
  "api/Platform.Sandbox.TerminalExperiment.html": {
    "href": "api/Platform.Sandbox.TerminalExperiment.html",
    "title": "Class TerminalExperiment | LinksPlatform",
    "keywords": "Class TerminalExperiment Inheritance System.Object TerminalExperiment Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class TerminalExperiment Properties IsRunning Declaration public static bool IsRunning { get; set; } Property Value Type Description System.Boolean Methods LinkCreated(LinkDefinition) Declaration public static void LinkCreated(LinkDefinition createdLink) Parameters Type Name Description LinkDefinition createdLink Run() Declaration public static void Run()"
  },
  "api/Platform.Sandbox.TextParser.html": {
    "href": "api/Platform.Sandbox.TextParser.html",
    "title": "Class TextParser | LinksPlatform",
    "keywords": "Class TextParser Inheritance System.Object TextParser Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class TextParser : IDisposable Constructors TextParser() Declaration public TextParser() TextParser(Stream, Int32) Declaration public TextParser(Stream stream, int bufferSize = 81920) Parameters Type Name Description Stream stream System.Int32 bufferSize TextParser(String, Int32) Declaration public TextParser(string path, int bufferSize = 81920) Parameters Type Name Description System.String path System.Int32 bufferSize Methods Dispose() Declaration public void Dispose() Implements System.IDisposable"
  },
  "api/Platform.Sandbox.TextParser.State.html": {
    "href": "api/Platform.Sandbox.TextParser.State.html",
    "title": "Class TextParser.State | LinksPlatform",
    "keywords": "Class TextParser.State Inheritance System.Object TextParser.State Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax protected class State Fields ParsedFromPath Declaration public string ParsedFromPath Field Value Type Description System.String ResultSequence Declaration public Link ResultSequence Field Value Type Description Link"
  },
  "api/Platform.Sandbox.Transactions.html": {
    "href": "api/Platform.Sandbox.Transactions.html",
    "title": "Class Transactions | LinksPlatform",
    "keywords": "Class Transactions Inheritance System.Object Transactions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class Transactions Methods Run() Declaration public static void Run()"
  },
  "api/Platform.Sandbox.TreeStructureExperiments.html": {
    "href": "api/Platform.Sandbox.TreeStructureExperiments.html",
    "title": "Class TreeStructureExperiments | LinksPlatform",
    "keywords": "Class TreeStructureExperiments Inheritance System.Object TreeStructureExperiments Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public static class TreeStructureExperiments Methods RunExperiment() Declaration public static void RunExperiment()"
  },
  "api/Platform.Sandbox.Walker1.html": {
    "href": "api/Platform.Sandbox.Walker1.html",
    "title": "Class Walker1 | LinksPlatform",
    "keywords": "Class Walker1 Inheritance System.Object ConsolePrintedDublicateWalkerBase Walker1 Inherited Members ConsolePrintedDublicateWalkerBase.OnDublicateFound(CharSegment) ConsolePrintedDublicateWalkerBase.CreateSegment(IList<Char>, Int32, Int32) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Walker1 : ConsolePrintedDublicateWalkerBase Methods GetSegmentFrequency(CharSegment) Declaration protected override long GetSegmentFrequency(CharSegment segment) Parameters Type Name Description CharSegment segment Returns Type Description System.Int64 Iteration(CharSegment) Declaration protected override void Iteration(CharSegment segment) Parameters Type Name Description CharSegment segment SetSegmentFrequency(CharSegment, Int64) Declaration protected override void SetSegmentFrequency(CharSegment segment, long frequency) Parameters Type Name Description CharSegment segment System.Int64 frequency WalkAll(IList<Char>) Declaration public override void WalkAll(IList<char> elements) Parameters Type Name Description System.Collections.Generic.IList < System.Char > elements"
  },
  "api/Platform.Sandbox.Walker2.html": {
    "href": "api/Platform.Sandbox.Walker2.html",
    "title": "Class Walker2 | LinksPlatform",
    "keywords": "Class Walker2 Inheritance System.Object ConsolePrintedDublicateWalkerBase Walker2 Inherited Members ConsolePrintedDublicateWalkerBase.OnDublicateFound(CharSegment) ConsolePrintedDublicateWalkerBase.CreateSegment(IList<Char>, Int32, Int32) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Walker2 : ConsolePrintedDublicateWalkerBase Methods GetSegmentFrequency(CharSegment) Declaration protected override long GetSegmentFrequency(CharSegment segment) Parameters Type Name Description CharSegment segment Returns Type Description System.Int64 Iteration(CharSegment) Declaration protected override void Iteration(CharSegment segment) Parameters Type Name Description CharSegment segment SetSegmentFrequency(CharSegment, Int64) Declaration protected override void SetSegmentFrequency(CharSegment segment, long frequency) Parameters Type Name Description CharSegment segment System.Int64 frequency WalkAll(IList<Char>) Declaration public override void WalkAll(IList<char> elements) Parameters Type Name Description System.Collections.Generic.IList < System.Char > elements"
  },
  "api/Platform.Sandbox.Walker3.html": {
    "href": "api/Platform.Sandbox.Walker3.html",
    "title": "Class Walker3 | LinksPlatform",
    "keywords": "Class Walker3 Inheritance System.Object ConsolePrintedDublicateWalkerBase Walker3 Inherited Members ConsolePrintedDublicateWalkerBase.OnDublicateFound(CharSegment) ConsolePrintedDublicateWalkerBase.CreateSegment(IList<Char>, Int32, Int32) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Walker3 : ConsolePrintedDublicateWalkerBase Methods GetSegmentFrequency(CharSegment) Declaration protected override long GetSegmentFrequency(CharSegment segment) Parameters Type Name Description CharSegment segment Returns Type Description System.Int64 Iteration(CharSegment) Declaration protected override void Iteration(CharSegment segment) Parameters Type Name Description CharSegment segment SetSegmentFrequency(CharSegment, Int64) Declaration protected override void SetSegmentFrequency(CharSegment segment, long frequency) Parameters Type Name Description CharSegment segment System.Int64 frequency WalkAll(IList<Char>) Declaration public override void WalkAll(IList<char> elements) Parameters Type Name Description System.Collections.Generic.IList < System.Char > elements"
  },
  "api/Platform.Sandbox.Walker4.html": {
    "href": "api/Platform.Sandbox.Walker4.html",
    "title": "Class Walker4 | LinksPlatform",
    "keywords": "Class Walker4 Inheritance System.Object Walker4 Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Walker4 : DictionaryBasedDuplicateSegmentsWalkerBase<char, CharSegment> Constructors Walker4() Declaration public Walker4() Methods CreateSegment(IList<Char>, Int32, Int32) Declaration protected override CharSegment CreateSegment(IList<char> elements, int offset, int length) Parameters Type Name Description System.Collections.Generic.IList < System.Char > elements System.Int32 offset System.Int32 length Returns Type Description CharSegment OnDublicateFound(CharSegment) Declaration protected override void OnDublicateFound(CharSegment segment) Parameters Type Name Description CharSegment segment WalkAll(IList<Char>) Declaration public override void WalkAll(IList<char> elements) Parameters Type Name Description System.Collections.Generic.IList < System.Char > elements"
  },
  "api/Platform.Sandbox.Zadacha.html": {
    "href": "api/Platform.Sandbox.Zadacha.html",
    "title": "Class Zadacha | LinksPlatform",
    "keywords": "Class Zadacha Inheritance System.Object Zadacha Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Platform.Sandbox Assembly : cs.temp.dll.dll Syntax public class Zadacha Fields StepsFor7DigitPhoneNumbers Declaration public const int StepsFor7DigitPhoneNumbers = 6 Field Value Type Description System.Int32 Methods RunAll() Declaration public void RunAll() RunOne() Declaration public void RunOne()"
  },
  "doc/articles/documenting_tutorial.html": {
    "href": "doc/articles/documenting_tutorial.html",
    "title": "Documentation tutorial | LinksPlatform",
    "keywords": "Documentation tutorial Table of Contents Introduction The First Steps Github Documenting Introduction ⚠️ This tutorial is made for working from IDE, text editor. You can try another way: document from github directly. In this tutorial our team will try to plunge you into actions before reading theory if possible to prevent mood like\\ I am reading these XML tags and cannot imagine how to use them \\ You can skip any chapter if you think you have enough knowledge about it. Questions? Ask them on out official Discord server . The First Steps See what documenting is Open any repository with ready documentation Look on the text after \\\\\\ . It is XML Documentation comments See result Get your own channel in Discord Join discord server Write in main/documenting chat \"I want to document code\" Get your documentation task Choose any documentation task from to-do on documentation projects board Say it in your own discord channel chat. Example: \"I would like to take this task - link \" GitHub Create an account Get invite to linksplatform Clone repository Create a branch. \\ Use command github branch . Example: github branch username_documenting Checkout the branch. Use command github checkout . Example: github checkout username_documenting Documenting Write three forward-slashes( /// ) before method\\ After that your IDE will create required tags for documentation. Now you see the draft that you will be working on. It is much better than reading XML tags and have no imagination about how you will use them Read Recommended XML tags for C# documentation \\ Do not read all the page at once. At first read about tags created by your IDE. Then you can sequentially read other tags that you will meet less often Kick out your perfectionism. Kick out your fears. Read the method body. If you do not understand something, try to get information from internet. Example: I see Math.Pow in the code and do not know what is it. I will search Math.Pow in my browser and will find result from docs.microsoft.com . Click on result link and you will see that this method Returns the largest integral value less than or equal to the specified number. Write your first thoughts about what this method does in XML tags. Save changes ( CTRL+S ) Commit changes to your branch \\ Use git commit -m \"MESSAGE\" command. Example git commit -m \"Update Life.AddHappiness() XML Docs\" Push the commits to the remote repository. Use git push command. Open the repository, open pull request TODO"
  },
  "doc/articles/links-theory.html": {
    "href": "doc/articles/links-theory.html",
    "title": "Черновик Теории Связей | LinksPlatform",
    "keywords": "Черновик Теории Связей Вступление Середина XX века связана с появлением единой теории универсальных вычислительных машин, называемых сегодня машинами Тьюринга. Название это в наши дни стало нарицательным и является синонимом любого вычислительно устройства в связи с широким признанием этой теории обществом. Именно эта технология вдохновила технических специалистов по всему миру на активное развитие вычислительной техники. Именно Аланом Тьюрингом в то же время был поставлен вопрос о том, может ли мыслить машина, и о том, а не является ли человек машиной. Всё это привело к началу активного исследования вопроса о возможности создания искусственного интеллекта (ИИ), неотличимого от человеческого интеллекта. И хотя сравнение таких комплексных систем возможно лишь в ограниченной степени, и часто происходит лишь на узком круге задач, таких как ведение беседы между двумя интеллектами или ведение игры и т.п., всё же успехи в этой области есть и с каждым годом их количество увеличивается, а качество повышается. Всё это шаг за шагом ведёт к тому, что мы лучше понимаем себя, узнаём новые возможности и ограничения человеческого интеллекта, и, перенося полученные знания в теорию вычислительных машин, с каждым разом всё глубже проникаем в суть того, как эти внешние эффекты, возможности, ограничения можно воспроизвести в рукотворном интеллекте, как именно это всё может быть устроено изнутри, и всё это шаг за шагом приближает нас к созданию новых технических систем, которые, улучшая старые образцы, всё ближе подходят к тому, что можно назвать интеллектуальным, разумным, умным. Всё это однажды и завершится той самой точкой сингулярности, когда будет создана такая мыслящая система, которая сможет улучшать и развивать сама себя и сможет решать любую задачу, которую поставит ей человек, в том числе и создание автономного искусственного интеллекта со своей волей, т.е. самостоятельно определяющего свои цели — так называемый интеллект сильного типа. У искусственного интеллекта сильного типа могут быть и эмоции, что с одной стороны позволило бы лучше ему понимать нас, людей, как мы, воспринимая чужие эмоции, лучше понимаем друг друга; с другой стороны это позволило бы нам ещё глубже понимать самих себя и то, как мы устроены. Но ИИ сильного типа не обязательно создавать напрямую, его может однажды создать ИИ слабого типа, который сам и не будет обладать своей волей, но если ИИ слабого типа будет создан, то цель ему может быть поставлена человеком. Поэтому можно сказать, что ИИ слабого типа будет достаточно, чтобы реализовать рано или поздно ИИ любого типа, любой сложности, с любой мощностью и с любым набором \"встроенных\" характеристик. Важно так же осознавать, что есть различные риски для общества в связи с развитием подобных технологий. Так же как и у других результатов технологического прогресса всё будет определено тем, кто и как будет применять эти результаты. Для того же, кто последует путём разработки, следует дать рекомендацию, что вероятнее всего ИИ сильного типа будет необходимо содержать в изоляции от общества и окружающей среды, постепенно и под контролем снимая ограничения. Такой контроль и осуществление ограничений, установленных человеком, сможет осуществлять ИИ слабого типа, человек же, скорее всего, успеть среагировать уже не сможет. Это похоже на то, как в семье родителями осуществляется контроль над ребёнком, и на то, как контроль осуществляется законом в обществе над каждым его гражданином. Авторов этой теории интересовал в первую очередь вопрос понимания того, что такое интеллект, из чего он состоит, и, следовательно, без чего он не может существовать. Так же как Машина Тьюринга не может быть вычислителем без наличия ленты с нулями и единицами, так и интеллект не может существовать без памяти. С одной стороны, можно поставить равенство между лентой Машины Тьюринга и \"памятью\" любого интеллекта. Тогда в сущности получится, что интеллект есть ни что иное как вычислительная машина. В таком случае уже сегодня существует множество искусственных интеллектов! Получается ли тогда, что и \"точки сингулярности\" мы уже достигли? Пожалуй, нет. Может ли сегодня любая вычислительная машина самостоятельно, без программиста адаптировать себя под окружающую среду, определить или вспомнить свою цель, сравнить окружение с целевым образом, и если различия всё ещё присутствуют — продолжить их устранять? Пусть и не любая, тогда существует ли хотя бы одна такая машина сегодня? Иначе этот критерий можно сформулировать так: существует ли машина, заранее не запрограммированная на решение задачи, которая, если ей такое описание задачи предоставить, смогла бы за приемлемое время составить, найти, или иными способами сгенерировать алгоритм или последовательность действий, решающих эту задачу так, чтобы это удовлетворило бы постановщика задачи? Такой критерий может соответствовать искусственному интеллекту слабого типа. Для ИИ сильного типа этот критерий можно усложнить тем, что помимо решения любых решаемых задач (см. проблему остановки Машины Тьюринга) такая машина в качестве одной из задач, постоянно решаемых, должна будет включать задачу поддержания своей \"жизни\", т.е. сохранять свою интеллектуальную функцию автономно (самостоятельно, независимо от человека), а помимо этого такая машина должна самостоятельно для себя решать, какие цели или задачи она будет выполнять \"дополнительно\". Причём подобная постановка критерия приведёт к тому, что ИИ сильного типа будет подвержен \"естественному отбору\" так же, как и любое живое существо биологического типа, в основе которого лежит ДНК-программа. Вероятно, и для ИИ сильного типа потребуется подобрать \"ДНК-программу\", определяющую его \"тело\" и \"разум\", в который должна быть встроена \"программа заботы о теле\" или \"программа саморепликации\". Если первая \"минимальная программа\" спровоцирует создание \"вечно живущего\" разума, то вторая спровоцирует создание целой популяции разумов \"размножающихся делением\". Такую \"минимальную\" программу для ИИ сильного типа мог бы аналитически вывести или генетически подобрать (вырастить), а также протестировать в ограниченной среде (или в реальной среде, но с ограничениями) уже ИИ слабого типа. Тестирование какого-либо ИИ не вводя ограничений может привести к непредсказуемым последствиям. С того момента, когда найдётся тот, кто все ограничения снимет, мы однозначно перейдём в эпоху, момент перехода в которую и называют точкой сингулярности. Есть риски действия, есть риски и бездействия. Уже сегодня многие крупные корпорации начали гонку за лучший \"сервис\" и тем или иным способом внедряют элементы \"интеллектуальных\" систем, контроль за которыми сегодня осуществляют программисты. Возможно, и государства занимаются чем-то подобным. Суть в том, что вычислительные машины уже сегодня есть у всех, и если кто-то однажды угадает тот заветный \"минимальный алгоритм\" — точка сингулярности сама по себе наступит непредсказуемо быстро. Если у нас не будет средств быстрого реагирования и защиты от высокоинтеллектуальных систем, мы рискуем за кратчайший срок получить либо значительный ущерб, либо потерять контроль над неопределённой заранее по размерам части доступных нам вычислительных ресурсов, что, как и первое, может привести всё к тем же непредсказуемым последствиям. Чем-то контролирующая система похожа на антивирус, а вот \"объект исследований\" ИИ сильного типа на вирус. И то, и другое действует в некоторой степени автономно, \"контролирующая\" система собственной волей не обладает, \"исследуемая\" система тоже своей волей обычно не обладает, однако самостоятельно поддерживает свою жизнедеятельность. Иными словами, ИИ слабого типа чем-то похож по внешним признакам на сегодняшние антивирусы, а ИИ сильного типа, развивающийся путём \"размножения делением\", а также путём самомодификации, будет иметь много общего с вирусами сегодняшнего дня. Все эти общее признаки в сегодняшнем объёме знаний человечества одному человеку увидеть и понять может быть затруднительно. Но всё же технология требует глубокого понимания, чтобы осознать её мощь и возможности, а также, зная её \"слабые места\", возыметь силу её обуздать. Ведь даже сегодня антивирусы способны бороться с тем, что уже однажды нанесло ущерб, а что, если бы антивирус мог бы самостоятельно выработать защиту от заранее неизвестной угрозы, которая начала наносить вред или только готовится его нанести? Ведь это могло бы предотвратить больше ущерба, и, в свою очередь, в будущем не позволило бы и различным ИИ сильного типа воспользоваться слабыми местами сегодняшних вычислительных систем. Что, если бы вместо программистов уязвимости, пусть даже какие-то их части, устраняли бы автоматизированные роботы-программисты? Это позволило бы быстрее реагировать на угрозы. Уже сегодня чувствуется необходимость в системах, реагирующих быстрее человека, однако обладающих гибкостью, подобной человеческой. Мы утопаем в море информации на разных языках, которая всё ещё медленно переводится, и увеличивается то время, которое проходит до качественного использования этой информации каждым человеком на планете. Уникальные идеи сложно находить. А работы по актуальным времени задачам многократно дублируются на разных языках независимо друг от друга, что негативно сказывается на темпах развития человечества в целом, замедляя эти самые темпы. До сих пор статьи в Википедии не синхронизированы и не приведены к единому виду с переводами на все языки, что заставляет читателя сравнивать статьи с одним и тем же по смыслу корнем, названием между языками. Опыт различных культур всё ещё ограниченно доступен носителям других культур и языков. Тем временем, расслоение наблюдается и в языках программирования, и разделяется, следовательно, и сообщество людей, одни и те же задачи решаются по-разному на разных языках программирования, и одно единое решение не вырабатывается или вырабатывается, но очень медленно. Видится огромный пласт задач и проблем, на решение которых не мешало бы направить искусственный интеллект, освободить тем самым руки и внимание людей уже под задачи более высокого уровня. Всё это сегодня развивается в среде, которую нам предоставила физическая реализация Машины Тьюринга в сегодняшних компьютерах. Но это требует особой категории людей — программистов — для развития. А так как таких людей не хватает, сегодняшние корпорации вынуждены закрывать код, придумывать способы продать эту закрытую технологию и обеспечить тем самым доходом программистов. Да и программисты здесь — неизбежный на данном этапе элемент. Их ещё никто не автоматизировал, и, следовательно, так как им нужны деньги, чтобы они продолжали работать — развитие технологий медленное и имеет высокую стоимость. И простая жадность мотивирует защищать капитал, т.е. код, закрывая его от публики, помогая сохранить конкурентное преимущество, но замедляя развитие остальной части человечества. Примеры целой группы/класса проблем можно перечислять очень долго, ещё дольше можно рассуждать, к какому ускорению развития привело бы решение целого класса задач. И, для приближения качественного решения другого уровня, т.е. ИИ, кажется, требуется провести ретроспективу, т.е. пересмотр того, а к чему, собственно, привело введение в обиход Машин Тьюринга. Каждый день сегодня в работе программисту требуется долго и мучительно адаптировать, казалось бы, очевидное решение под конкретное окружение и конкретную архитектуру. Подбирать множество разных структур данных, если выбор стоит в плоскости независимой разработки, учитывать особенности железа и проверять, чтобы код превращался в нужный набор инструкций, чтобы достичь высокого уровня производительности. И ведь всё это происходит на \"универсальной машине Тьюринга\", где не нужно переделывать машину под каждую задачу, а достаточно переделать только код машины. Кажется, этой модели не хватает чего-то. По крайней мере, так оно и выглядело для авторов несколько лет назад, когда выполнялся поиск подходящей среды для экспериментов в области искусственного интеллекта. Самыми близкими к требуемым критериям универсальности, гибкости и простоты были Lisp-системы и Lisp-машина, вводящие универсальные списки, последовательности, и СУБД, построенная на основе ассоциативной модели памяти Sentences, разработанная Симоном Вильямсом, вводящая тройные связи по модели Субъект-Глагол-Объект. И в эти связи, в отличии от рёбер теории графов, вносили важную модификацию. Связи могли ссылаться на связи, позволяя тем самым строить структуру предложений любой сложности для эффективной работы с данными на \"семантическом уровне\". Но по инерции из теории графов были переняты \"точки\" или \"элементы\", к которым и привязывались текстовые описания (значение этих элементов), те самые последовательности, списки символов. Изначально было принято решение, ввиду закрытости исходного кода Sentences, упростив модель, разработать своё открытое технологическое решение. Так связям было разрешено ссылаться и нам самих себя. А точки (\"элементы\") были полностью исключены из системы. В ходе экспериментов было показано, что можно хранить текстовые последовательности внутри \"Связей\". Так тогда назывался проект. Это означало, что модель прошла проверку и от Sentences можно отказаться, новая модель проще, гибче и включает в себя тот же функционал, не теряя из него ни одной возможности, которую предоставляла исходная закрытая система. Также следует подчеркнуть, что в противоположность \"закрытому коду\" выбран путь развития через \"открытый код\", что само по себе упрощает переориентировку на всё человечество в целом, в противоположность ряду закрытых групп людей и сообществ. Обозначения Для однозначности в передаче смысла излагаемого в Теории Связей важно заранеее условиться, т.е. договориться о смысле, значении, которым будут обладать различные обозначения, графические знаки, символы и конструкции. Для установки смысловой связи будет использоваться обычный текст на языке, которым владеет читатель. В данном случае это русский язык. Позднее текст может быть переведён на другие языки. Во-первых, сразу возникает вопрос, а как отличить, разграничить текст и эталонные обозначения. Попробуем и здесь воспользоваться средствами русского языка. Русский язык допускает использование перечислений, бывает так, что перечисление начинается с вводного слова, а затем после двоеточия через запятую перечисляется некоторое множество, например: \"цвета: красный, зелёный, синий\". А ещё только что мы использовали цитирование. Ещё перечисление может быть представлено на нескольких строчках, например так: \"цвета: красный зелёный синий\" Иными словами, список как бы занимает весь следующий абзац или строчку. Но ведь множество может состоять из одного элемента, например: \"множество: элемент\" В этой систуации вводное слово находится на одной строчке, а элемент множества — на другой. Что ж, приступим теперь к первому обозначению, которое нам понадобится: ⛶ Познакомьтесь, это пустая часть. Часть представляет собой нечто целое, но отделённое от остальной информации в тексте. Часть может быть любого размера и занимать всю строку: ⸢ ⸣ ⸤ ⸥ А может быть встроена в текст внутри строки подобно слову или символу, например так — ⛶. Часть можно сравнить с коробкой, в которую можно что-то положить, например: [[]]. Тут мы положили внутри одной части другую пустую часть. Вкладывать по такому принципу можно без ограничения: [[[]]]. Тут уже 3 уровня вложенности, и чем больше таких уровней, тем больше часть начинает быть похожа на матрёшку, так знакомую русскому человеку. Можно было бы рисовать части и так: ▢, но для экономии краски, чернил, будем считать, что достаточно обозначить только углы части ⛶. Ещё такой подход позволит не путать часть с квадратом или прямоугольником, и тогда в части можно будет складывать фигуры: ⸢ ⸣ ⸢ ⸣ ⸢ ⸣ □ △ ○ ⸤ ⸥, ⸤ ⸥, ⸤ ⸥. А вот соответствующие этим фигурам слова: [квадрат], [треугольник], [окружность]. Оказалось, что в части можно даже вставлять текст, а на самом деле — всё что угодно или в нашем случае всё, что может быть графически обозначено на бумаге. Ещё частями можно заменить скобки и обозначение выражений, например: \"((3+2)+6)\" превращается в [[3+2]+6]. Сама по себе часть чем-то похожа на цитату и обозначается тоже 4-мя линиями, только ломаными: сравните \"\" и ⛶. Но бывает так, что мы имеем нечто целое, но разделённое на части, тогда и блок можно разделить: ⸢ ⸣ ⸢ ⸣ ⸢ ⸣ ⛶ ⛶⛶ ⛶⛶⛶ 1 часть 2 части 3 части ⸤ ⸥, ⸤ ⸥, ⸤ ⸥. Причём больше всего это похоже на 1-3 части, состыкованные вместе, но граница между частями рисуется одна и общая. Если вы сталкивались с таблицами, например в продукте от Microsoft — Excel или в терминах реляционных СУБД, то уже могли заметить, что такие части, состоящие из частей, начинают быть похожими на таблицы. Но и это ещё не всё, вы действительно сможете увидеть таблицы такого рода: ┌ ┬ ┐ ⛶⛶ ▢▢ ⛶⛶ ▢▢ ├ ┼ ┤ составая обычная часть с таблица двумя с двумя столбцами столбцами и двумя и двумя строками строками └ ┴ ┘ Как видите, часть на то и часть, что в неё даже можно вписать таблицы, но и в таблицы можно вставлять части. Итак, подведём итоги: Знак Его значение ⛶ пустая часть [[]] пустая часть, вписанная в другую часть ⛶⛶ часть, состоящая из двух частей, например множество/последовательность ⊞ часть, состоящая из 4-х частей, например таблица, матрица Пустые связи Пустые связи или связи состоящие из нуля ссылок на связи, это связи представляющие собой ничто, или отсутствие этих связей. Графически это можно выразить пустотою: ⸢ ⸣ ⸤ ⸥ Причём в такой пустой части пространства может и не располагатся ни одной такой пустой связи, а так же это равносильно тому что в этой части рсполагается одна пустая связь, сама часть, но точно? пустота в ней и обозначает пустую связь, так же это равносильно и тому, что в этой части располагается бесконечное количество пустых связей. В общем, получается, что мы сразу графически рассмотрели все случаи изображения всех возможных пустых связей и сразу в любом их количестве. Причём эти пустые связи, если они там и есть могут располагаться в любом объёме пространства даже сколь угодно маленьком и даже в отсутствии пространства можно было бы разместить целую бесконечность пустых связей, но чтобы можно было графически ссылаться содержимое части необходимо заполнить хоть каким-то пространством, а для удобства его можно сделать не большим, как выше, а размером со строчный символ: ⛶, этого тоже будет достаточно, чтобы ссылаться на пустые связи или на их отсутствие, по своей сути смысл отсутствие связей или одной связи эквивалентен. Но сма часть при этом пустой является лишь от части. Т.е. часть полна пространством, но в ней нет графических обозначений чего либо, такое отсутствие графики внутри части и есть пустота. Иными словами не сама часть эквивалентна пустым связям, но пустота в ней. Однако две пустые части эквивалентны и равны: \"⛶ <=> ⛶; ⛶ = ⛶\". Само символическое обозначение ⛶ ссылается на \"пустую часть\", а пустота в этой части может означать и \"пустые связи\". Конечно у пустых связей может быть адрес, и можно обращаться к 1-й, второй и т.п. связям например так: [①], [②], и т.п. но всё они равны по смыслу, а значит: ⛶ = [①] = [②] и т.п. В итоге хотя и множно множество пустых связей делить на элементы, каждый элемент равен любому другому и самому множеству. Единичные связи Единичные связи или связи состоящие из одной ссылки на другую связь. Графически это может выражаться вот так: ... Сама по себе связь содержащая ссылку на связь может представлять только два состояния: это либо связь-точка, т.е. она ссылается сама на себя, либо это связь-синоним. Синоним может быть прямым, т.е. например это 2-я и 6-я связь и косвенным это 7-я и 3-я связь. По своей структуре такие связи могут образовывать: \"точки\", \"цепочки\" и \"деревья\", причём во всех случаях нельзя будет связать две отдельных точки или два отдельных синонима. А отсюда следует, что, такие связи не подходят для формирования самопределяющихся последовательности, и не могут представить через себя ни двойную связь, ни связи большей мерности. Так как связи не обладают характеристикой размера их можно в бесконечном количестве расположить на сколь угодно малом пространстве, причём графически это может обозначить как заполненное краской пространство, так и одной лишь грфической точки. Если конечно внешне назначить каждой связи дополнительное значение, то, конечно можно использовать эти структуры для хранения \"точек\", \"цепочек\" и \"деревьев\" с привязанными к ним значениями. Но сами единичные связи можно представить через двойные связи, например так: ... * в дальнейшем обозначение адреса связи примет свою однозначную форму, а именно ...4... и ...4... ** единичные связи не могут иметь направления. Двойные связи Двойные связи или связи смысл которых или значение состоящие из двух ссылок на другие связи. Графически могут изображаться так: ... 1-\"точка\"; 4-\"пара точек\" 2 и 3; 3-\"корень цепочки с элементом\"2; 11-\"внутреннее дерево\" или \"последовательность из 4-х элементов\" 5, 6, 8 и 9; 12-\"внешнее дерево\"; 13 - \"цикл\" или \"замкнутая цепочка из 3-х элементов\" 17, 18 и 19. В отличии от единичной связи двойная связь двойная связь связь может связывать любые другие две связи путём установки на них двух ссылок. Есть так же два варинта интерпретации связей, они могут быть направлены, тогда первая ссылка зовётся \"началом\", а последняя (в данном случае вторая) зовётся \"концом\"; они могут быть и не направлены, тогда обе ссылки равнозначны и дополнительного смысла кроме связывание двух в единое не несут. Вне завимости от направления эти связи могут быть: \"точками\", \"парами\" и \"частичными точками\". \"Частичной точкой\" считается такая связь у которой только одна ссылка указывает на себя, а другая обязательно н другую связь. \"Полной точкой\" или просто \"точкой\" называется такая связь у которой обе ссылки указывают на себя саму. \"Парой\" называют такие связи обе ссылки которых указывают на другие связи. По своей структуре связи могут организовывать как внутренние, так и внешние структуры, тем самым покрывая любые возможные формы сетевых структур. Последовательности Тройные связи и связи с N количеством ссылок на другие связи могут быть представлены в виде последовательностей, которые построены из двойных связей. (добавлено 23.02.2021). Понятие \"степени сжатия\" В ассоциативной памяти (сети) состоящей из двойных связей (пар) для построения строгой упорядоченной последовательности (частный случай множества элементов, а именно их размещения) требуется представлять элементы в виде структуры похожей на бинарное дерево (ациклический граф), где левым поддеревом или левой подпоследовательностью является начало связи, представляющей заданную последовательность, а правым поддеревом или правой подпоследовательностью является конец этой же связи. Деление на последовательность и подпоследовательность условно, подпоследовательностью называется составная часть последовательности, которая в то же время может представлять собой и самостоятельную последовательность. Проще говоря последовательность либо сама есть элмент, либо стоит из двух других последовательностей. На заметку: Последнее определение рекурсивно, а значит уже включает все комбинации: последовательность из двух элементов; последовательность из элемента и последовательности; и последовательность из двух последовательностей. Самим же размещением является положени элементов (листьев) дерева относительно друг друга слева на право или наоборот (в зависимости от принятого в системе направления за основное), при этом \"высота\", \"уровень\" или \"глубина\" расположения элементов игнорируется. Из этого следует, что любая структура дерева вне зависимости от его формы (структуры), но с определённым количеством элементов и самими элементами может представлять одну и ту же последовательность. Например: последовательность \"я\" состоит из одного элемента (символа в данном случае) и представляется самим этим элементом: (я) или я ; последовательность \"да\" состоит из двух элементов и представляется связью между ними (д)->(f) или да ; последовательность \"нет\" состоит из трёх элементов и равнозначно может быть представлено двумя \"деревьями\" связей, а именно двумя связями: (н)->((е)->(т)) или н(ет) и ((н)->(е))->(т) или (не)т . Продолжая приводить примеры подобные указанным выше, но содержащие большее число элементов начинают в точности соответствовать количеству и формам всех возможных вариантов деревьев для каждого количества элементов в отдельности и соответствует фактически последовательности \"Каталановых чисел\" (Catalan Numbers). Оценивая количество возможных построений последовательностей состоящих из 20 и более элементов легко прийти к выводу, что хранение всех возможных форм одной и той же последовательности на любом реальном физическом носителе, либо не имеет практического смысла, либо ввиду ограниченности доступных нам ресурсов невозмож с учётом такого ограничения. Не много в хранении всех её форм и теоретического смысла, ведь согласно первой аксиоме логики об идентичности \"а=а\", можно заключить что сам факти существования последовательности может запечатлён любой из его форм, так как из определения последовательности следует, что благодаря игнорированию \"вертикальной\" структуры они все эквивалентны одной и той же \"горизонтальной\" структуре. Встаёт вопрос: А как выбрать тот единственный вариант построения последовательности из всех возможных? Иными словами, что лучше выбрать н(ет) или (не)т ? Но прежде чем отвечать на такой вопрос оценим, а какие последствия нас ожидают, если мы на этот вопрос не ответим? Ведь не на всякий вопрос, возможно нужно отвечать... Тут пожалуй всё просто, если мы сохраним все формы или хотя бы по две из них для каждой последовательности мы во-первых вводим систему (множество последовательностей) в противоречие с первой аксиомой логики (об идентичности) и всегда имеем ситуацию, когда у нас есть больше одной и той же по своему смыслу последовательности, т.е. \"а!=a\". Сдругой стороны и во-вторых при хранении на физическом носителе можно крайне быстро исчерпать весь ресурс доступного \"информационого\" или \"адресного\" пространства. Ну а манипуляция такими объёмами памяти приведёт так же к большим затратам по времени исполнения операций записи и чтения. Пожалуй достаточно оснований для того, чтобы заранее поставить этот теоретический вопрос? Чтобы выбор был оптимальным с точки зрения приведённых выше последствий, нужно, чтобы все из этих \"негативных\" последствий были сведены к минимумму. А значит оптимальной будет ситуация, когда каждая последовательность и следовательно каждая \"подпоследовательность\" будет существовать минимальное число раз, а в нашем случае это фактически 1, т.е. ровно один раз. И желательно в каждый момент времени до и после каждой операции над последовательностями в экземпляре ассоциативной памяти. Чем фактически будет обеспечено минимально возможное использование физического пространства на информационном носителе. Так же будет сведён к минимуму объём вычислительных мощностей требуемых для чтения и записи (трансформации) последовательностей, если не считать неизбежную жертву в такой ситуации - память и время вычисления, которые будут направлены на выбранный аппарат хранения, структуризации и трансформации этих последовательностей. Для оценки качества или близости к оптимальному случаю (ситуации) мы и введём понятие \"степень сжатия последовательности\". На практике могут опускаться некоторые требования оптимальной ситуации для экономии или более эффективного использования ресурсов. Например можно допускать дубликаты в то время, пока от системы требуется максимальная отзывчивость (скорость реакции), а \"упаковку\", \"сжатие\" или \"структуризацию\" откладывать на время \"сна\" системы, т.е. времени в течении которого реакция на внешнюю среду не требуется. Это чем-то похоже на остановку выполнения при \"сборке мусора\" в средах поддерживающих объектно-ориентированный подход. Позволим себе некоторое отступление от темы. Вообще проблема выбора, сама по себе имеет очень глубкие исторические корни, например до сих пор существуют различные языки, которые можно разделить однозначно на две категории: использующие направление записи слева на право, так и справа на лево. Хотя с другой стороны при чтении в слух или при переводе из письменного в акустический носитель можно заметить, что ранее разделённые по направлению написания сигналы получаются едины в направлении произношения. Причём эта же проблема выбора имеет отражение и в ассоциациях с добром и злом, жизнью и смертью, \"походом налево\" и \"православием\" и т.п. Хотя и здесь события являются шаблоном трансформации, но в зависимости от набора аксиом (принимаемых за истину вариантов формы отношения к фактам/событиям) может быть оценено совершенно по разному, при том, что сама трансформация и её направление (шакала времени) остаётся неизменнной относительно всех \"наблюдателей\", ещё такое называют \"объективным, а отношение каждого наблюдателя субъективным. Ещё субъективной формой отношения к событиям (частичным трансформациям) называется интерпретация т.е. в данном случае \"отношение\" подразумевает процесс изменения (модификации) воспринимаемого носителя информации для формирования точного образа (модели), или можно сказать восстановление, распаковка передаваемой/воспринимаемой модели в сознании (оперативной памяти, оперативном состоии системы) субъекта, до необходимого уровня детализации, для использования в процессе реализации целей субъекта, с допустимым уровнем искажения исходного события. Причём первичное скажение вносится добавлением субъективной оценки или вывода возникающего при сравнении с аксиомами принимаемым за истину, которые не редко выводятся из \"эталона\", \"примера\", \"образца\", \"традиции\", иначе говоря некоторого шаблона трансформации, который субъектом принимается за \"достойный\" повторения или \"необходимый\" к повторению для приведения окаружающей его части глобальной трансформации к желаемому \"виду\", форме, шаблону, и за счёт повторения фактически усилиями субъекта приводимый в относительно \"неизменное состояние\", \"постоянное состояние.\". Причём есть общая, глобальная трансформация не является зависимой от субъекта полностью, то при продолжении применения некоторого шаблона действий он фактически приводит к некоторому образцу лишь часть эффектов общей трансформации, либо лишь отдельные аспекты того, что его окружает. Если же воздействие субъекта пекращается то желаемый шаблон формы может быть утерян, если не осталось больше носителей такого желания, но если воздейсвие было достаточно длительно, обширно или ярко/контрастно, у такого шаблона действий (примера) и такого шаблона формы (цели) в таком шаблоне окружения (истока) может образовывать множество дополнительных носителей шаблона действий, которые либо уже вошли в \"привычку\", либо являются единственным оптимальным выходом (исходном) из сложившегося шаблона окружения. Такие дополнительные носители обычно называются \"последователи\", а шаблон действий \"традицией\". Возвращаясь к теме определения \"степени сжатия\", попробуем описать его более формально (точнее). Для этого возьмём два крайних случая - последовательность из одинаковых элементов и из уникальных относительно друг друга элементов. Для примера будем использовать всего 4 элемента: [○] [△] [□] [☆]. Из этих элементов составим две последовательности: [○] [○] [○] [○] и [☆] [○] [□] [△]. Такие последовательности выбраны не случайно, только при длине в 4 элемент начинает проявляться эффект \"сжатия\". Последовательности длиною в 1-3 элемента ведут себя одинаково вне зависимости от содержания: ... Иными словами все характеристики последовательности и её структуры остаются одни и те же, даже при различном содержании элементов в последовательности. Под \"всеми характеристиками\" имеются ввиду: высота структуры последовательности (В), длина последовательности или количество элементов в последовательности (Д) и количество возможных вариантов (способов) построения дерева, представляющего структуру последовательности (П). Итак рассмотрим теперь последовательности с длиной равной четырём элементам. У обоих вариантов будет по 5 способов построения. Фактически \"П\" всегда зависит только от \"Д\". Мы не будем даваться во все возможные варианты построения, а возьмём для каждого из двух вариантов содержание последовательности с длиной 4 по два крайних случая, назовём их \"сжатый\" и \"несжатый\". И введём ещё одну характеристику для оценки - количество связей необходимых на саму структуру дерева, представляющего эти последовательности (С). ... Как видно из примеров, теперь характеристика (С) зависит от содержимого последовательности, так как каждая пара может существовать в ассоциативной памяти только один раз, то в случае с одинаковыми элементами появляется так же и одинаковые пары, например [○] [○] используется дважды. А вот в случае уникальных элементов одинаковых пар не образуется. А именно появление и повторное использование одни и тех же пар приводит к экономии пространства под необходимое для структуры количество связей (С). Можно так же заметить, что в случае последовательности состоящей из уникальных элементов количество связей на структуру не будет зависеть от самой формы этой структуры: ... Однако при выборе структуры ещё можно сократить высоту, но относительно \"степени сжатия\" данный случай называется \"несжимамаемым\" и обусловлен тем, что внутри последовательности все элементы уникальны друг относительно друга. С другой стороны если какие либо пары последовательности внутри экземпляра ассоциативной памяти не уникальны, т.е. используются например двумя разными последовательностями, то даже в этом, казалось бы \"худшем случае\" возможно сжатие, т.е. частичнае или полное повторное использование которое и проводит к экономии свободного пространства. ... В этом примере [☆] [○] используется дважды, и тем самым мы получаем сжатие на 1 связь, т.е. экономию одной связи в свободном пространстве. Хотя если бы обе последовательности хранились отдельно, потребовалось бы 6, а не 5 связей. Отсюда следует вывод, что \"сжатием\" мы называем количество \"съэкономленных связей\", а вот \"степенью сжатия\" будем считать соотношение \"худшего\" возможного случая при организации структуры последовательности к текущему варианту, а само значение степени будем выражать в \"%\" или долях т.е. например \"степень сжатия\" в последнем примере это 5/6 или (100/6 * 5)% = 83,3(3)% = 83,(3)%. \"Лучшим\" же возможным случаем в альтернативу приведённого примера будет \"объединение\" двух одинаковых последовательностей в одну и использование одинаковых элементов вместо уникальных, что при \"двух\" последовательностях будет 2/6, а если бы это была одна последовательность из 4-х элементов, то 2/3. Степень сжатия на иллюстрации можно обозначить как СС*. Степень сжатия в примерах введена одновременно с написанием этого примечания. Получается, что есть два схожих термина: \"степень сжатия совокупности последовательностей\" и \"степерь сжатия отдельной последовательности\". Ещё второй термин можно обозначить как \"самостоятельная степень сжатия последовательности\". Но в обоих случаях чем меньше долью целого выражается степень сжатия, тем больше свободного пространства мы экономим, т.е. сохраняем для более эффективного использования. Алгоритмы построения последовательностей Лесенка Алгоритм построение последовательностей в ассоциативной памяти, состоящий из парных связей: \"последовательный вариант\", \"лесенка\", или \"список\". Тестирование алгоритма происходит на примере \"длинной\" и \"коротких\" последовательностей, но в контексте одного экземпляра памяти. Создадим \"длинную\" последовательность ... Создадим \"короткие\" последовательности входящие в \"длинную\" а) ... Все связи уже существовали, поэтому дополнительных связей создавать не потребовалось. Иными словами, если у последовательностей общее в точности начало, на построение структуры новых связей тратить не требуются. б) ... Две связи уже существовали, однако потребовалось ещё 4. Хотя по факту, они избыточные, так как существует такая структура, при которой при создании подпоследовательностей уже входящих в существующую, при которой никаких новых связей не потребуется. в) ... 4 связи уже были, 1 добавилась. Итоги и выводы Всего \"создавалось\" или \"вносилось в ассоциативную память\" 4 последовательности, 3 из которых входят в 4-ю последовательность. Итого было внесено последовательностей общей длиной (23+7+8+6), т.е. 44 \"символа\" или \"элемента\". Всего использовалось уникальных элементов-символов: \"з\", \"е\", \"ё\", \"л\", \"н\", \"а\", \" \", \"я\",\"ь\". Т.е. 9 штук, что означает что для их хранения нужно не менее 9 связей. Итого на символы и последовательности ушло 9+27 связей. 27 связей ушло на организацию структуры последовательностей. Исходя из того, что в худшем случае (при пустой ассоациативной памяти или отсутствии повторно используемых пар, а в случае данного алгоритма достаточно отсутствия первой пары последовательности, чтобы она создавалась \"худшим образом/случаем\", т.е. каждая связь необхдимая для организациии структуры последовательности была создана вновь и ни одна не была использована повторно) на построение последовательности уходит на одну связь меньше чем общее число элементов в последовательности, а именно в данном случае: ((23-1)+(8-1)+(7-1)+(6-1)) = 40 связей. Если степень сжатия соотношение количествая связей в частном случае по отношению к худшему случаю при организации структуры последовательностей, то в нашем случае средней степенью сжатия будет 27/40 = 13,5/20 = 6,75/10 = 67,5% Стоит заметить, что хотя этот алгоритм и является олицетворением или точнее сказать синонимом \"худшего случая\" при отдельном рассмотрении каждой последовательности, но при совокупном рассмотрении даже этот алгоритм выдаёт достаточно высокую степень сжатия, хотя конечно с некоторой вероятностью, которая зависит от структуры конкретных последовательностей и наличия у них общих частей, а именно общих начал (или концов, в зависимости от ориентации применения алгоритма). Балансированный вариант \"Длинные\" и \"короткие\" последовательности на примере \"балансированного варианта\". Создади \"длинную\" последовательность ... Создадим \"короткие\" последовательности входящие в \"длинную\" а) ... Пока всё \"замечательно\": каждая пара из \"короткой\" подпоследовательности, входящей в \"длинную\" уже существовало и новых связей, представляющих пары создавать не потребовалось. б) ... Здесь уже \"не всё так чудесно\", одна пара уже существовала, но потребовалось создать её 5 связей. в) ... 3 связи уже были, 2 добавилось. Итоги и выводы Всего \"создавалось\" или \"вносилось в ассоциативную память\" 4 последовательности, 3 из которых входят в 4-ю последовательность. Итого было внесено последовательностей общей длиной (23+7+8+6), т.е. 44 \"символа\" или \"элемента\". Всего использовалось уникальных элементов-символов: \"з\", \"е\", \"ё\", \"л\", \"н\", \"а\", \" \", \"я\",\"ь\". Т.е. 9 штук, что означает что для их хранения нужно не менее 9 связей. Итого на символы и последовательности ушло 9+26 связей. 26 связей ушло на организацию структуры последовательностей. Исходя из того, что в худшем случае (при пустой ассоациативной памяти или отсутствии повторно используемых пар, а в случае данного алгоритма достаточно отсутствия первой пары последовательности, чтобы она создавалась \"худшим образом/случаем\", т.е. каждая связь необхдимая для организациии структуры последовательности была создана вновь и ни одна не была использована повторно) на построение последовательности уходит на одну связь меньше чем общее число элементов в последовательности, а именно в данном случае: ((23-1)+(8-1)+(7-1)+(6-1)) = 40 связей. Если степень сжатия соотношение количествая связей в частном случае по отношению к худшему случаю при организации структуры последовательностей, то в нашем случае средней степенью сжатия будет 26/40 = 13/20 = 6,5/10 = 65% Этот алгоритм выдаёт достаточно высокую степень сжатия, с некоторой вероятностью, которая зависит от структуры конкретных вносимых последовательностей, а именно от наличия у них общих частей, причём большее число общих частей возможно в том случае, если направление разбиения последовательности на пары совпадает с направлением разбиения уже ранее созданной части. Или иными словами для совпдания частей и составных из них, требуется чтобы разбиение на пары у обоих частей начиналось либо у обоих с конца к началу, либо у обоих с начала к концу, иначе совмещение и повторное использование будет невозможно и породит дополнительный дубликат."
  },
  "index.html": {
    "href": "index.html",
    "title": "Links Platform (русская версия) | LinksPlatform",
    "keywords": "Links Platform ( русская версия ) Holistic system for storage and transformation of information (in development) based on associative model of data. Prerequisites Linux, macOS or Windows operating system. .NET Core SDK with version 2.2 or later. MonoDevelop , Visual Studio or any other IDE or just a text editor . Links Platform's NuGet packages Main packages Platform.Data Common interfaces and classes for both Doublets and Triplets . Platform.Data.Doublets An implementation of Doublets. Platform.Data.Triplets A C# adapter of Triplets. Platform.Data.Triplets.Kernel A native Triplets implementation. Auxiliary packages Platform.Data.Memory Platform.Data.Memory class library contains classes for memory management simplification. There you can find multiple implementations of IMemory interface. The data can be accessed using the raw pointer or by element's index and can be stored in volatile memory: HeapResizableDirect , ArrayMemory or in non-volatile memory: FileMappedResizableDirectMemory , TemporaryFileMappedResizableDirectMemory , FileArrayMemory . Platform.Data.Communication Platform.Data.Communication class library contains classes for communication simplification supporting different protocols. Gexf XML-mapping classes for Graph Exchange XML Format . Udp UdpSender and UdpReceiver classes to simplify implementation of different roles of UdpClient . Xml A Serializer class to help with XML serialization and deserialization. Platform.Collections.Methods Platform.Collections.Methods class library contains classes with storage/state agnostic implementation of lists and trees. Platform.IO Platform.Collections.Methods class library contains classes ... . Platform.Unsafe Platform.Collections.Methods class library contains classes ... . Platform.Numbers Platform.Collections.Methods class library contains classes ... . Platform.Converters Platform.Collections.Methods class library contains classes ... . Platform.Scopes Platform.Collections.Methods class library contains classes ... . Platform.Singletons Platform.Collections.Methods class library contains classes ... . Platform.Reflection Platform.Collections.Methods class library contains classes ... . Platform.Threading Platform.Collections.Methods class library contains classes ... . Platform.Collections Platform.Collections.Methods class library contains classes ... . Platform.Diagnostics Platform.Collections.Methods class library contains classes ... . Platform.Counters Platform.Collections.Methods class library contains classes ... . Platform.Setters Platform.Collections.Methods class library contains classes ... . Platform.Comparers Platform.Collections.Methods class library contains classes ... . Platform.Random Platform.Collections.Methods class library contains classes ... . Platform.Timestamps Platform.Collections.Methods class library contains classes ... . Platform.Ranges Platform.Collections.Methods class library contains Range struct with Minimum and Maximum fields. Platform.Disposables Platform.Collections.Methods class library contains classes and interfaces that help to make objects disposable in a fast, short, easy and safe way. DisposableBase Platform.Disposables.DisposableBase abstract class tries to dispose the object at both on instance destruction and OnProcessExit whatever comes first even if Dispose method was not called anywhere by user. Yet another IDisposable The Platform.Disposables.IDisposable interface extends the System.IDisposable with IsDisposed property and Destruct method. Platform.Exceptions Platform.Collections.Methods class library contains classes ... . Platform.Interfaces Platform.Collections.Methods class library contains common interfaces that did not fit in any major category."
  },
  "index.ru.html": {
    "href": "index.ru.html",
    "title": "Платформа Связей (english version) | LinksPlatform",
    "keywords": "Платформа Связей ( english version ) Целостная система для хранения и обработки информации (в разработке), основанная на ассоциативной модели данных. Требования Операционная система Linux, macOS или Windows. .NET Core SDK версии 2.2 или выше. MonoDevelop , Visual Studio или любая другая ИСР или просто текстовый редактор . NuGet пакеты Платформы Связей Основные пакеты Platform.Data Общие интерфейсы и классы для Дуплетов и Триплетов . Platform.Data.Doublets Platform.Data.Triplets Platform.Data.Triplets.Kernel Вспомогательные пакеты Platform.Data.Memory Библиотека классов Platform.Data.Memory содержит классы для упрощения управления памятью. Там вы можете найти множество реализаций интерфейса IMemory . Доступ к данным может осуществляться через указатель или через индексатор и данные могут храниться в энергозависимой памяти: HeapResizableDirect , ArrayMemory или в энергонезависимой памяти: FileMappedResizableDirectMemory , TemporaryFileMappedResizableDirectMemory , FileArrayMemory . Platform.Data.Communication Platform.Collections.Methods Platform.IO Platform.Unsafe Platform.Numbers Platform.Converters Platform.Scopes Platform.Singletons Platform.Reflection Platform.Threading Platform.Collections Platform.Diagnostics Platform.Counters Platform.Setters Platform.Comparers Platform.Random Platform.Timestamps Platform.Ranges Platform.Disposables Platform.Exceptions Platform.Interfaces"
  },
  "README.html": {
    "href": "README.html",
    "title": "LinksPlatform (русская версия) | LinksPlatform",
    "keywords": "LinksPlatform ( русская версия ) The Links Platform is a modular framework , that includes two DBMS implementations based on the associative data model : Doublets and Triplets ; as well as translators (for example from C# to C++ ) and bot . Each library of this framework can be used separately and located at the Links Platform organization page . At the moment we use C# , C++ , C , JavaScript and Python programming languages . Documentation Graphical introduction Quick start example using System; using Platform.Data; using Platform.Data.Doublets; using Platform.Data.Doublets.Memory.United.Generic; // A doublet links store is mapped to \"db.links\" file: using var links = new UnitedMemoryLinks<uint>(\"db.links\"); // A creation of the doublet link: var link = links.Create(); // The link is updated to reference itself twice (as a source and a target): link = links.Update(link, newSource: link, newTarget: link); // Read operations: Console.WriteLine($\"The number of links in the data store is {links.Count()}.\"); Console.WriteLine(\"Data store contents:\"); var any = links.Constants.Any; // Means any link address or no restriction on link address // Arguments of the query are interpreted as restrictions var query = new Link<uint>(index: any, source: any, target: any); links.Each((link) => { Console.WriteLine(links.Format(link)); return links.Constants.Continue; }, query); // The link's content reset: link = links.Update(link, newSource: default, newTarget: default); // The link deletion: links.Delete(link); SQLite vs Doublets Description Inspired by the work of Simon Williams ( The Associative Model of Data ), book , whitepaper . Comparison of models: Comparison of theories: This platform uses a unified data type — link, which is a combination of Item and Link from a work by Simon Williams. So the Item or Point is a specific case of the link, which references itself . There are two variants of Link structure: Untyped , each link contains Source ( beginning , start , first , left , subject ) and Target ( ending , stop , last , right , predicate , object ). Typed ( semantic ), with added Linker ( verb , action , type , category , predicate , transition , algorithm ), so any additional info about a type of connection between two links can be stored here. Links Platform planned as a system , that combines simple associative memory storage (Links) and transformation execution engine (Triggers). There will be an ability to program that system dynamically, due to the fact that all algorithms will be treated as data inside the storage . Such algorithms can also change themselves in real-time based on input from the environment . The Links Platform is a method of modeling the high-level associative memory effects of human mind . One of the most important goals of the project is to accelerate the development of automation to the level when automation can be itself automated. In other words, this project should help to implement a bot-programmer which will be able to create programs based on descriptions in human language. Road map Project status Swagger Connector Concept Links (doublets) API swagger connector. Links (triplets, micro RDF) API swagger connector. Frequently asked questions Support Ask questions at stackoverflow.com/tags/links-platform (or with tag links-platform ) to get our free support. You can also get real-time support on our official Discord server . Contacts https://vk.com/linksplatform https://vk.com/konard"
  },
  "README.ru.html": {
    "href": "README.ru.html",
    "title": "ПлатформаСвязей (english version) | LinksPlatform",
    "keywords": "ПлатформаСвязей ( english version ) Платформа Связей — это модульный фреймворк , в который входят две реализации СУБД на основе ассоциативной модели данных : Дуплеты и Триплеты ; а также трансляторы (например из C# в C++ ) и бот . Каждая из библиотек этого фреймворка может быть использована отдельно и располагается на странице организации \"Платформы Связей\" . В данный момент мы используем следующие языки программирования : C# , C++ , C , JavaScript and Python . Документация Графическое вступление Пример для быстрого старта using System; using Platform.Data; using Platform.Data.Doublets; using Platform.Data.Doublets.Memory.United.Generic; // Хранилище дуплетов привязывается к файлу \"db.links\": using var links = new UnitedMemoryLinks<uint>(\"db.links\"); // Создание связи-дуплета: var link = links.Create(); // Связь обновляется чтобы ссылаться на себя дважды (в качестве начала и конца): link = links.Update(link, newSource: link, newTarget: link); // Операции чтения: Console.WriteLine($\"Количество связей в хранилище данных: {links.Count()}.\"); Console.WriteLine(\"Содержимое хранилища данных:\"); var any = links.Constants.Any; // Означает любой адрес связи или отсутствие ограничения на адрес связи // Аргументы запроса интерпретируются в качестве органичений var query = new Link<uint>(index: any, source: any, target: any); links.Each((link) => { Console.WriteLine(links.Format(link)); return links.Constants.Continue; }, query); // Сброс содержимого связи: link = links.Update(link, newSource: default, newTarget: default); // Удаление связи: links.Delete(link); SQLite против Дуплетов Описание Вдохновлено работой Симона Вильямса ( Ассоциативная модель данных - англ. ), книга (англ.) , сравнение с реляционными моделями данных (англ.) . Сравнение моделей данных: Сравнение теорий: Эта платформа использует объединённый тип данных — связь, который является комбинацией Элемента и Связи из оригинальной работы Симона Вильямса. Таким образом Элемент или Точка являются частным случаем связи, которая ссылается сама на себя . Есть два варианта структуры Связи: Нетипизированная, каждая связь содержит Source (Начало, Подлежащее) и Target (Конец, Сказуемое, Дополнение). Типизированная, с добавленным Linker (Глагол, Тип, Связка, Предикат, Сказуемое), так, что теперь любая дополнительная информация о типе соединения между двумя связями может быть записана в это дополнительное поле. Платформа Связей запланирована как система, которая комбинирует хранилище ассоциативной памяти (Связи) и движок выполнения трансформаций (Триггеры). Эту систему можно будет программировать динамически, благодаря тому факту, что все алгоритмы будут восприниматься как данные внутри этого хранилища. Такие алгоритмы также способны изменять сами себя в режиме реального времени на основе входных данных из окружающей среды. Платформа Связей это один из способов моделирования высокоуровневых эффектов ассоциативной памяти человеческого разума. Одна из важнейших целей проекта — ускорить развитие автоматизации до того уровня, чтобы можно было автоматизировать саму автоматизацию. Другими словами, этот проект должен позволить реализовать бота-программиста, который смог бы создавать программы на основе описания на человеческом языке. Дорожная карта Текущее состояние разработки (англ.) Концепт Swagger Connector Links (doublets) API swagger connector. Links (triplets, micro RDF) API swagger connector. Часто задаваемые вопросы Support Задавайте вопросы по адресу stackoverflow.com/tags/links-platform (или с тегом links-platform ) чтобы получить нашу бесплатную поддержку. Вы так же можете получить поддержку в режиме реального времени на нашем официальном Discord сервере . Контакты https://vk.com/linksplatform https://vk.com/konard"
  }
}